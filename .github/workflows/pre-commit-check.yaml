# If this workflow failed in your PR, run `pre-commit install` and commit your files again.
# See instructions in the README.md in the repo root for more details.
name: Run pre-commit to check that formatting is correct
on:
  pull_request:

jobs:
  pre_commit:
    name: "pre-commit"
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # ratchet:actions/checkout@v6.0.0

      - uses: actions/setup-python@e797f83bcb11b83ae66e0230d6156d7c80228e7c # ratchet:actions/setup-python@v6.0.0
        with:
          python-version: "3.14"
          cache: "pip"

      # Only run it on changed files with: https://github.com/pre-commit/action/issues/7
      - id: changed-files
        uses: tj-actions/changed-files@24d32ffd492484c1d75e0c0b894501ddb9d30d62 # ratchet:tj-actions/changed-files@v47

      - uses: pre-commit/action@2c7b3805fd2a0fd8c1884dcaebf91fc102a13ecd # ratchet:pre-commit/action@v3.0.1
        id: pre-commit
        continue-on-error: true
        with:
          extra_args: --files ${{ steps.changed-files.outputs.all_changed_files }}

      # Capture the diff of proposed changes
      - name: Get proposed changes
        if: steps.pre-commit.outcome == 'failure' && github.event_name == 'pull_request'
        id: get-diff
        run: |
          # Get the diff of changes that pre-commit would make
          git diff > proposed-changes.diff

          # Check if there are actual changes
          if [ -s proposed-changes.diff ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            # Store diff for use in the next step, escaping for JSON
            DIFF_CONTENT=$(cat proposed-changes.diff)
            echo "diff_content<<EOF" >> $GITHUB_OUTPUT
            echo "$DIFF_CONTENT" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      # Post proposed changes as review comments with suggestions
      - name: Post proposed changes
        if: steps.get-diff.outputs.has_changes == 'true' && github.event_name == 'pull_request'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # ratchet:actions/github-script@v8.0.0
        with:
          script: |
            const crypto = require('crypto');
            const diff = `${{ steps.get-diff.outputs.diff_content }}`;

            // Get all existing comments to check for duplicates
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            // Parse the diff into file chunks
            const diffLines = diff.split('\n');
            let currentFile = null;
            let currentHunk = null;
            let fileChanges = [];

            for (let i = 0; i < diffLines.length; i++) {
              const line = diffLines[i];

              // New file in diff
              if (line.startsWith('diff --git')) {
                if (currentFile && currentHunk) {
                  fileChanges.push({ file: currentFile, hunk: currentHunk });
                }
                currentFile = null;
                currentHunk = null;
              } else if (line.startsWith('--- a/')) {
                currentFile = line.substring(6);
              } else if (line.startsWith('+++ b/')) {
                if (!currentFile) {
                  currentFile = line.substring(6);
                }
              } else if (line.startsWith('@@')) {
                // Save previous hunk if exists
                if (currentFile && currentHunk) {
                  fileChanges.push({ file: currentFile, hunk: currentHunk });
                }

                // Parse hunk header: @@ -start,count +start,count @@
                const match = line.match(/@@ -(\d+),?\d* \+(\d+),?\d* @@/);
                if (match) {
                  currentHunk = {
                    oldStart: parseInt(match[1]),
                    newStart: parseInt(match[2]),
                    oldLines: [],
                    newLines: [],
                    contextBefore: [],
                    contextAfter: []
                  };
                }
              } else if (currentHunk) {
                // Collect the changes
                if (line.startsWith('-')) {
                  currentHunk.oldLines.push(line.substring(1));
                } else if (line.startsWith('+')) {
                  currentHunk.newLines.push(line.substring(1));
                } else if (line.startsWith(' ')) {
                  // Context line
                  if (currentHunk.oldLines.length === 0 && currentHunk.newLines.length === 0) {
                    currentHunk.contextBefore.push(line.substring(1));
                  } else {
                    currentHunk.contextAfter.push(line.substring(1));
                  }
                }
              }
            }

            // Save last hunk
            if (currentFile && currentHunk) {
              fileChanges.push({ file: currentFile, hunk: currentHunk });
            }

            // Filter out changes that already have suggestions posted
            const newChanges = [];
            for (const change of fileChanges) {
              const { file, hunk } = change;
              const suggestionContent = hunk.newLines.join('\n');

              // Create a unique marker for this specific suggestion
              const hash = crypto.createHash('md5').update(file + suggestionContent).digest('hex').substring(0, 8);
              const marker = `<!-- pre-commit-suggestion-${hash} -->`;

              // Check if this exact suggestion already exists
              const alreadyExists = comments.some(comment => comment.body.includes(marker));

              if (!alreadyExists) {
                newChanges.push({ ...change, marker });
              }
            }

            // Only post a comment if there are new suggestions
            if (newChanges.length > 0) {
              let body = "⚠️ **Pre-commit checks failed!** ⚠️\n\n";
              body += "Pre-commit hooks would make the following changes. You can apply each suggestion directly:\n\n";

              for (const change of newChanges) {
                const { file, hunk, marker } = change;

                // Add the unique marker for this suggestion
                body += marker + "\n";
                body += `### \`${file}\` (line ${hunk.newStart})\n\n`;

                // Create suggestion block
                body += "```suggestion\n";
                body += hunk.newLines.join('\n');
                if (hunk.newLines.length > 0 && !hunk.newLines[hunk.newLines.length - 1].endsWith('\n')) {
                  body += '\n';
                }
                body += "```\n\n";
              }

              body += "---\n\n";
              body += "**To fix this:**\n";
              body += "1. Apply the suggestions above directly in GitHub, or\n";
              body += "2. Run `pre-commit install` locally and commit again (auto-fixes issues), or\n";
              body += "3. Apply these changes manually\n\n";
              body += "If you need help, refer to the [README](https://github.com/" + context.repo.owner + "/" + context.repo.repo + "/blob/main/README.md).\n";

              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }

      # Fail the workflow if pre-commit failed
      - name: Fail if pre-commit failed
        if: steps.pre-commit.outcome == 'failure'
        run: exit 1
